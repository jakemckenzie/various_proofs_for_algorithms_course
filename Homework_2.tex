\documentclass[paper=a4,fontsize=11pt]{article}
\usepackage{amsmath,amssymb,amsthm}
\usepackage[protrusion=true,expansion=true]{microtype}	
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage[margin=1.5in]{geometry}
\setlength{\textfloatsep}{0.1cm}
\setlength{\floatsep}{0.1cm}

\begin{document}
\title{TCSS 343 - Assignment 1}
\author{Jake McKenzie}
\maketitle
\begin{enumerate}
\item [(3 points) 1.] Below is a self-reduction for the \texttt{MAX} problem. State a recursive algorithm using pseudocode for finding the maximum element based on this self-reduction.\\
\begin{algorithm}
\caption{Find Max integer in an Array with simple recursion}
\label{array-max}
\begin{algorithmic}[1]
\Procedure{Find Max}{$A$}
    \If{($a == b$)}
        \State return A[a]
    \ElsIf{($a < b$)}
        \State return Max(A[a],Find Max(A[a + 1]))
    \EndIf
\EndProcedure
\Procedure{Max}{$a,b$}
    return ($a < b$) ? b : a
\EndProcedure
\end{algorithmic}
\end{algorithm}
\item [(6 points) 2.] Using the same reduction as part 1 now state a recurrence $T(n)$ that expresses the worst case run time of the recursive algorithm. Find a similar recurrence in your notes and state the tight bound on $T(n)$.\\\\\
Line 3 makes $1$ amount of operations while line 5 makes $T(n-1)$, this is because there are $n-1$ amount of comparisons to check for the max in the recurrence for when this list is greater than 1. **Note**: Consistency of whether the constant amount of operations is writen as $1$ or $O(1)$ are inconsistent so I went with the notation I've seen the most used often.
\[
  T(n) =
    \begin{cases}
        1 & \text{if $n = 1$} \\
        T(n-1) + 1 & \text{if $n > 1$}
    \end{cases}
\]
Claim: $\forall n > 0$, the running time of \textit{Find Max} $\epsilon O(n)$. We consder the recurrance relation above.
\begin{enumerate}
\item[1.] Base Case:\\
$$n = 1; T(1) = 1$$
\item[2.] Inductive Hypothesis:\\
\[
  T(k) =
    \begin{cases}
        1 & \text{if $k = 1$} \\
        T(k-1) + 1 & \text{if $k > 1$}
    \end{cases}
\]
\\Assume for an arbitrary $k, T(k) \leq k$
\item[3.] Inductive Step:
\begin{gather*}
\text{if $k > 1$}\\
T(k + 1) = T(k) + 1\\
T(k + 1) \leq k + 1\\  
T(k + 1) \leq k + 1\\
T(k + 1) \epsilon O(k)\\
\therefore\\
T(k) \epsilon O(k)\\
\end{gather*}
\end{enumerate}
\item [(9 points) 3.] Below is a self-reduction for the \texttt{MAX} problem. State a recursive algorithm using pseudocode for finding the maximum element based on this self-reduction.\\\\\
\[
M(A[a\dots b]) = \left\{
\begin{array}{cl}
-\infty & \textrm{ if } a > b\\
A[a] & \textrm{ if } a = b\\
\max(M(A[a\dots t_1]), \max(M(A[t_1+1\dots t_2]), M(A[t_2+1\dots b]))) & \textrm{ if } a < b
\end{array}
\right.
\]
\begin{algorithm}
\caption{Find Max integer in an Array with 3-Way Split}
\label{array-max}
\begin{algorithmic}[1]
\Procedure{Find Max}{$A,a,t_1,t_2$}
    \If{($a > b$)}
        \State return 0x7FFFFFFF
    \ElsIf{($a == b$)}
        \State return A[a]
    \ElsIf{($a < b$)}
        \State return Max(FindMax(A,a+1,$t_1$,$t_2$), Max(FindMax(A, a, $t_1$+1,$t_2$), FindMax(A, a, $t_1$,$t_2$+1]))
    \EndIf
\EndProcedure
\Procedure{Max}{$a,b$}
    return (a $<$ b) ? b : a
\EndProcedure
\end{algorithmic}
\end{algorithm}\\
For what it's worth, I don't think this algorithm will find the max element if it is contained within the first third of the array(we never iterate over the first third elements, only the second and last third), but it does match the self-reduction.
\item [(7 points) 4.] Using the same reduction as part 3 now state a recurrence $T(n)$ that expresses the worst case run time of the recursive algorithm. You do not need to formally prove your recurrence, but you have to show that it is a reasonable guess by using a recursion tree or by the repeated substitution method.
\textit{Hint: assume that $n$ is a power of 3}.\\\\
I assumed, for purposes of the problem, that we did iterate through each third of the array evenly and like you said that $n = 3^\psi$. Intuitively I expect this to be a worst case linear runtime, which case each last element of the subarrays would be a local max but let propose a semi-formal argument for such. Let us assume the following recurrence reduction.
\[
  T(n) =
    \begin{cases}
        1 & \text{if $n = 1$} \\
        3T(\frac{n}{3}) + d & \text{if $k > 1$}
    \end{cases}
\]
\begin{align*}
\text{if $k > 1$ and $let n = 3^\psi$}\\
T(n) &= 3T(\frac{n}{3}) + d\\
T(n) &= 3T(3^{\psi - 1}) + 3^{\psi} + d\\
T(n) &= 3T(3^{\psi - 2}) + 3^{\psi - 1} + 3^{\psi} + d\\
T(n) &= 3T(3^{\psi - 3}) + 3^{\psi - 2} + 3^{\psi - 1} + 3^{\psi}  + d\\
&\vdots\\
T(n) &= 3^{0} + \dots + 3^{\psi - 2} + 3^{\psi - 1} + 3^{\psi}  + d\\
T(n) &= \sum_{\psi=0}^{k}3^{\psi} + d\\
T(n) &= \frac{3^{k+1} - 1}{2} + d\\
T(n) &= \frac{3n - 1}{2} + d\\
T(n) &= \epsilon O(n)\\
\end{align*}\\
\end{enumerate}
\begin{enumerate}
\item [(12 points) 1.] State two different self-reductions for the \texttt{SUM} problem. Use the self-reduction examples from the lectures as a guide.\\
\\For this problem I decided to use divide and conquer for the second self-reduction and just normal recursion for the second. I don't think these are good ways to sum over an array, there are a lot of wasted computations but it is quite readable. The first algorithm simply completes a summation on the array in reverse order. The second algorithm sums the even and odd elements at the same time.{
\[
  T(n) =
    \begin{cases}
        1 & \text{if $n = 1$} \\
        T(n - 1) + 1 & \text{if $k > 1$}
    \end{cases}
\]
\[
  T(n) =
    \begin{cases}
        1 & \text{if $n = 1$} \\
        2T(\frac{n}{2}) + d & \text{if $k > 1$}
    \end{cases}
\]
}
\\\item [(12 points) 2.]{ Give recursive algorithms based on your divide-and-conquer self-reductions to solve the \texttt{SUM} problem.\\\\
\begin{algorithm}
\caption{Find Sum of an Array via Simple Recursion}
\label{array-sum}
\begin{algorithmic}[1]
\Procedure{Find Sum}{$A,n$}
    \If{($n \leq 0$)}
        \State return 0
    \Else
        \State return FindSum(A, n - 1) + A[n - 1]
    \EndIf
\EndProcedure
\end{algorithmic}
\end{algorithm}

\begin{algorithm}
\caption{Find Sum of an Array via Divide and Conquer}
\label{array-sum}
\begin{algorithmic}[1]
\Procedure{Find Sum}{$A,n$}
    \If{($n \leq 0$)}
        \State return 0
    \Else
        \State return FindSum(A, n-2) + FindSum(A, (n == n) ? n - 1 : n - 2) + A[n - 1]
    \EndIf
\EndProcedure
\end{algorithmic}
\end{algorithm}
}
\item [(6 points) 3.] What are the worst-case runtimes of the solutions you have generated. (Just state the runtimes. You do not need to show your work.)\\\\
Both algorithm operate in linear time with a worst case runtime of $O(n)$. In fact I can make the argument that both functions are $\Theta(n)$. I came to this conclusion from reading Tim Roughgarden's Algorithms Illuminated page 56-57 where he states then proves theorem $max\{f(n),g(n)\} = \Theta(f(n) + g(n))$. Both algorithms are bounded by some constant multiple of $n$, while algorithm 4 operates slightly slower than 3, they both follow this fact. If we take the max of the two, which would be algorithm 4, that still operates in linear time. From this information I came to the firm conclusion that both algorithms were operating in $\Theta(n)$. I hope this makes sense to you. I know it's a roundabout way of thinking about this problem but it's what helped me come to a conclusion so I thought I would include it.
\end{enumerate}
\end{document}