\documentclass[paper=a4,fontsize=11pt]{article}
\usepackage{amsmath,amssymb,amsthm}
\usepackage[protrusion=true,expansion=true]{microtype}	
\usepackage{algorithm}
\usepackage{algpseudocode}
\usepackage[margin=1.5in]{geometry}
\setlength{\textfloatsep}{0.1cm}
\setlength{\floatsep}{0.1cm}

\begin{document}
\title{TCSS 343 - Assignment 1}
\author{Jake McKenzie}
\maketitle
\begin{enumerate}
\item [(3 points) 1.] Below is a self-reduction for the \texttt{MAX} problem. State a recursive algorithm using pseudocode for finding the maximum element based on this self-reduction.\\
\begin{algorithm}
\caption{Find Max integer in an Array with simple recursion}
\label{array-sum}
\begin{algorithmic}[1]
\Procedure{Find Max}{$A$}
    \If{($a == b$)}
        \State return A[a]
    \ElsIf{($a < b$)}
        \State return Max(A[a],Find Max(A[a + 1]))
    \EndIf
\EndProcedure
\Procedure{Max}{$a,b$}
    return ($a < b$) ? b : a
\EndProcedure
\end{algorithmic}
\end{algorithm}
\item [(6 points) 2.] Using the same reduction as part 1 now state a recurrence $T(n)$ that expresses the worst case run time of the recursive algorithm. Find a similar recurrence in your notes and state the tight bound on $T(n)$.\\\\\
Line 3 makes $1$ amount of operations while line 5 makes $T(n-1)$, this is because there are $n-1$ amount of comparisons to check for the max in the recurrence for when this list is greater than 1. **Note**: Consistency of whether the constant amount of operations is writen as $1$ or $O(1)$ are inconsistent so I went with the notation I've seen the most used often.
\[
  T(n) =
    \begin{cases}
        1 & \text{if $n = 1$} \\
        T(n-1) + 1 & \text{if $n > 1$}
    \end{cases}
\]
Claim: $\forall n > 0$, the running time of \textit{Find Max} $\epsilon O(n)$. We consder the recurrance relation above.
\begin{enumerate}
\item[1.] Base Case:\\
$$n = 1; T(1) = 1$$
\item[2.] Inductive Hypothesis:\\
\[
  T(k) =
    \begin{cases}
        1 & \text{if $k = 1$} \\
        T(k-1) + 1 & \text{if $k > 1$}
    \end{cases}
\]
\\Assume for an arbitrary $k, T(k) \leq k$
\item[3.] Inductive Step:
\begin{gather*}
\text{if $k > 1$}\\
T(k + 1) = T(k) + 1\\
T(k + 1) \leq k + 1\\  
T(k + 1) \leq k + 1\\
T(k + 1) \epsilon O(k)
\end{gather*}
\end{enumerate}
\item [(9 points) 3.] Below is a self-reduction for the \texttt{MAX} problem. State a recursive algorithm using pseudocode for finding the maximum element based on this self-reduction.\\\\\
\[
M(A[a\dots b]) = \left\{
\begin{array}{cl}
-\infty & \textrm{ if } a > b\\
A[a] & \textrm{ if } a = b\\
\max(M(A[a\dots t_1]), \max(M(A[t_1+1\dots t_2]), M(A[t_2+1\dots b]))) & \textrm{ if } a < b
\end{array}
\right.
\]
\begin{algorithm}
\caption{Find Max integer in an Array with 3-Way Split}
\label{array-sum}
\begin{algorithmic}[1]
\Procedure{Find Max}{$A,a,t_1,t_2$}
    \If{($a > b$)}
        \State return 0x7FFFFFFF
    \ElsIf{($a == b$)}
        \State return A[a]
    \ElsIf{($a < b$)}
        \State return Max(FindMax(A,a+1,$t_1$,$t_2$), Max(FindMax(A, a, $t_1$+1,$t_2$), FindMax(A, a, $t_1$,$t_2$+1]))
    \EndIf
\EndProcedure
\Procedure{Max}{$a,b$}
    return (a $<$ b) ? b : a
\EndProcedure
\end{algorithmic}
\end{algorithm}\\
For what it's worth, I don't think this algorithm will find the max element if it is contained within the first third of the array(we never iterate over the first third elements, only the second and last third), but it does match the self-reduction.
\item [(7 points) 4.] Using the same reduction as part 3 now state a recurrence $T(n)$ that expresses the worst case run time of the recursive algorithm. You do not need to formally prove your recurrence, but you have to show that it is a reasonable guess by using a recursion tree or by the repeated substitution method.
\textit{Hint: assume that $n$ is a power of 3}.\\\\
I assumed, for purposes of the problem, that we did iterate through each third of the array evenly and like you said that $n = 3^\psi$. Intuitively I expect this to be a worst case linear runtime, which case each last element of the subarrays would be a local max but let propose a semi-formal argument for such. Let us assume the following recurrence reduction.
\[
  T(n) =
    \begin{cases}
        1 & \text{if $n = 1$} \\
        3T(\frac{n}{3}) + d & \text{if $k > 1$}
    \end{cases}
\]
\begin{align*}
\text{if $k > 1$ and $let n = 3^\psi$}\\
T(n) &= 3T(\frac{n}{3}) + d\\
T(n) &= 3T(3^{\psi - 1}) + 3^{\psi} + d\\
T(n) &= 3T(3^{\psi - 2}) + 3^{\psi - 1} + 3^{\psi} + d\\
T(n) &= 3T(3^{\psi - 3}) + 3^{\psi - 2} + 3^{\psi - 1} + 3^{\psi}  + d\\
&\vdots\\
T(n) &= 3^{0} + \dots + 3^{\psi - 2} + 3^{\psi - 1} + 3^{\psi}  + d + d\\
T(n) &= \sum_{\psi=0}^{k} + d\\
T(n) &= \frac{3^{k+1} - 1}{2} + d\\
T(n) &= \frac{3n - 1}{2} + d\\
T(n) &= \epsilon O(n)\\
\end{align*}\\
\end{enumerate}
\begin{enumerate}
\item [(12 points) 1.] State two different self-reductions for the \texttt{SUM} problem. Use the self-reduction examples from the lectures as a guide.

\item [(12 points) 2.] Give recursive algorithms based on your divide-and-conquer self-reductions to solve the \texttt{SUM} problem.

\item [(6 points) 3.] What are the worst-case runtimes of the solutions you have generated. (Just state the runtimes. You do not need to show your work.)

\end{enumerate}
\end{document}